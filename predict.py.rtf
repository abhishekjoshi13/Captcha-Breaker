{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 import tensorflow as tf\
import numpy as np\
from PIL import Image\
import string\
import os\
\
class CaptchaPredictor:\
    def __init__(self, model_path='captcha_model.h5'):\
        self.model_path = model_path\
        self.characters = string.ascii_uppercase + string.digits\
        self.char_to_idx = \{char: idx for idx, char in enumerate(self.characters)\}\
        self.idx_to_char = \{idx: char for idx, char in enumerate(self.characters)\}\
        self.sequence_length = 5\
        self.img_height = 50\
        self.img_width = 200\
        self.model = None\
        \
    def load_model(self):\
        if os.path.exists(self.model_path):\
            self.model = tf.keras.models.load_model(self.model_path)\
            return True\
        else:\
            print(f"Model file \{self.model_path\} not found. Please train the model first.")\
            return False\
        \
    def preprocess_image(self, image_path):\
        image = Image.open(image_path).convert('RGB')\
        image = image.resize((self.img_width, self.img_height))\
        image_array = np.array(image) / 255.0\
        image_array = np.expand_dims(image_array, axis=0)\
        return image_array\
    \
    def predict(self, image_path):\
        if not self.model:\
            if not self.load_model():\
                return "Model not available"\
        \
        try:\
            processed_image = self.preprocess_image(image_path)\
            predictions = self.model.predict(processed_image, verbose=0)\
            \
            captcha_text = ''\
            for i in range(self.sequence_length):\
                pred = predictions[i][0]\
                char_idx = np.argmax(pred)\
                captcha_text += self.idx_to_char[char_idx]\
                \
            return captcha_text\
        except Exception as e:\
            return f"Prediction error: \{e\}"\
\
def test_prediction():\
    predictor = CaptchaPredictor()\
    \
    test_images = [f for f in os.listdir('captcha_images') if f.endswith('.png')]\
    \
    if test_images:\
        test_image = os.path.join('captcha_images', test_images[0])\
        print(f"Testing prediction on: \{test_image\}")\
        \
        actual_text = os.path.splitext(test_images[0])[0]\
        predicted_text = predictor.predict(test_image)\
        \
        print(f"Actual CAPTCHA:    \{actual_text\}")\
        print(f"Predicted CAPTCHA: \{predicted_text\}")\
        print(f"Match: \{actual_text == predicted_text\}")\
    else:\
        print("No test images found in captcha_images directory")\
\
if __name__ == "__main__":\
    test_prediction()}